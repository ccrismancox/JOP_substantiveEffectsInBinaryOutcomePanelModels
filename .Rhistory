sqrt(diag(delta.sp))
cbind(AME.sp - 1.96*se.sp, AME.sp, AME.sp+1.96*se.sp)
AME.sp <- mean(s1$fitted*(1-s1@fitted))*s1$coeff[1:9]
AME.sp <- mean(s1$fitted*(1-s1$fitted))*s1$coeff[1:9]
cbind(AME.sp - 1.96*se.sp, AME.sp, AME.sp+1.96*se.sp)
se.sp <- sqrt(diag(delta.sp))
AME.sp <- mean(s1$fitted*(1-s1$fitted))*s1$coeff[1:9]
cbind(AME.sp - 1.96*se.sp, AME.sp, AME.sp+1.96*se.sp)
t(sp.mem.ci)
J.glm <- jac(g1$coefficients, var = vcov(g1), X=g1$x, k=1:9)
delta.glm <- J.glm %*% vcov(g1) %*% t(J.glm)
se.glm <- sqrt(diag(delta.glm))
AME.glm <- mean(g1$fitted*(1-g1$fitted))*g1$coeff[1:9]
glm.out <- data.frame(lo=AME.glm - 1.96*se.glm,
est=AME.glm,
high=AME.glm+1.96*se.glm,
est="MLDV")
glm.out
cre.mem.ci
cre.mem.ci <- data.frame(lo=cre.mem.ci[1,],
est=cre.mem.ci[2,],
hi=cre.mem.ci[3,],
method="CRE")
sp.mem.ci <- data.frame(lo=sp.mem.ci[1,],
est=sp.mem.ci[2,],
hi=sp.mem.ci[3,],
method="PML")
glm.mem.ci <- data.frame(lo=glm.mem.ci[1,],
est=glm.mem.ci[2,],
hi=glm.mem.ci[3,],
method="MLDV")
save(file="~/Documents/code/germanTesting.Rdata", list=c("cre.mem.ci", "glm.mem.ci", "sp.mem.ci"))
output <- rbind.data.frame(cre.mem.ci,sp.out,glm.out)
sp.out <- data.frame(lo=AME.sp - 1.96*se.sp,
est=AME.sp,
high=AME.sp+1.96*se.sp,
method="PML")
J.glm <- jac(g1$coefficients, var = vcov(g1), X=g1$x, k=1:9)
delta.glm <- J.glm %*% vcov(g1) %*% t(J.glm)
se.glm <- sqrt(diag(delta.glm))
AME.glm <- mean(g1$fitted*(1-g1$fitted))*g1$coeff[1:9]
glm.out <- data.frame(lo=AME.glm - 1.96*se.glm,
est=AME.glm,
high=AME.glm+1.96*se.glm,
method="MLDV")
output <- rbind.data.frame(cre.mem.ci,sp.out,glm.out)
save(file="~/Documents/code/germanTesting_easyOut.Rdata", list=c("output"))
sp.out <- data.frame(lo=AME.sp - 1.96*se.sp,
est=AME.sp,
hi=AME.sp+1.96*se.sp,
method="PML")
glm.out <- data.frame(lo=AME.glm - 1.96*se.glm,
est=AME.glm,
hi=AME.glm+1.96*se.glm,
method="MLDV")
output <- rbind.data.frame(cre.mem.ci,sp.out,glm.out)
ggplot(output) + geom_pointrange(aes(x=method, y=est, ylow=lo,yhigh=high))
library(ggplot2)
ggplot(output) + geom_pointrange(aes(x=method, y=est, ylow=lo,yhigh=high))
ggplot(output) + geom_pointrange(aes(x=method, y=est, ylow=lo,yhigh=hi))
ggplot(output) + geom_pointrange(aes(x=method, y=est, ymin=lo,ymax=hi))
names(sp.out$coeff)
names(sp.out$coeff)[1:9]
names(s1.out$coeff)[1:9]
names(s1$coeff)[1:9]
cre.mem.ci <- sapply(1:9,
function(x){quantile(rowMeans(dhat.cre*cre2.FE$MCMC[,x]), c(0.025, .5,.975))})
glm.mem.ci <- sapply(1:9,
function(x){quantile(rowMeans(dhat.glm*glm.boot[,x]), c(0.025, .5,.975))})
sp.mem.ci <- sapply(1:9,
function(x){quantile(rowMeans(dhat.sp*sp.boot[,x]), c(0.025, .5,.975))})
cre.mem.ci <- data.frame(lo=cre.mem.ci[1,],
est=cre.mem.ci[2,],
hi=cre.mem.ci[3,],
var=names(s1$coeff)[1:9],
method="CRE")
sp.mem.ci <- data.frame(lo=sp.mem.ci[1,],
est=sp.mem.ci[2,],
hi=sp.mem.ci[3,],
var=names(s1$coeff)[1:9],
method="PML")
glm.mem.ci <- data.frame(lo=glm.mem.ci[1,],
est=glm.mem.ci[2,],
hi=glm.mem.ci[3,],
var=names(s1$coeff)[1:9],
method="MLDV")
save(file="~/Documents/code/germanTesting.Rdata", list=c("cre.mem.ci", "glm.mem.ci", "sp.mem.ci"))
sp.out <- data.frame(lo=AME.sp - 1.96*se.sp,
est=AME.sp,
hi=AME.sp+1.96*se.sp,
var=names(s1$coeff)[1:9],
method="PML")
glm.out <- data.frame(lo=AME.glm - 1.96*se.glm,
est=AME.glm,
hi=AME.glm+1.96*se.glm,
var=names(s1$coeff)[1:9],
method="MLDV")
output <- rbind.data.frame(cre.mem.ci,sp.out,glm.out)
g2 <- ggplot(output)+
geom_pointrange(aes(x=var, y=est,ymin=lo,ymax=hi, color=method, shape=method, linetype=method),
position=position_dodge(width=.5), size=.85)+
ylab("Average marginal effects")+
xlab("")+
geom_abline(aes(intercept=0, slope=0), linetype="dashed")+
theme_bw(16)+
theme(text=element_text(family="CM Roman"),
legend.position = "bottom")+
coord_flip()
print(g2)
c1
save(file="~/Documents/code/germanTesting_easyOut.Rdata", list=c("output"))
cre2.fitted <- plogis(drop(sp1$X %*% cre2.FE$coefficients))
cre2.fitted <- plogis(drop(s1$X %*% cre2.FE$coefficients))
round(
cbind(mean(g1$fitted.values*(1-g1$fitted.values))*g1$coef[1:9],
mean(predict(cre1, type="response")*(1-predict(cre1, type="response")))*cre1@beta[2:10],
mean(cre2$fitted.values*(1-cre2$fitted.values))*cre2$coefficients[2:10],
mean(s1$fitted*(1-s1@fitted))*s1$coeff[1:9]),
3)
round(
cbind(mean(g1$fitted.values*(1-g1$fitted.values))*g1$coef[1:9],
mean(predict(cre1, type="response")*(1-predict(cre1, type="response")))*cre1@beta[2:10],
mean(cre2$fitted.values*(1-cre2$fitted.values))*cre2$coefficients[2:10],
mean(s1$fitted*(1-s1$fitted))*s1$coeff[1:9]),
3)
predict(c1)
plogis(predict(c1)) * plogis(predict(c1), lower=FALSE) * coef(c1)
mean(plogis(predict(c1)) * plogis(predict(c1), lower=FALSE)) * coef(c1)
round(
cbind(mean(plogis(predict(c1)) * plogis(predict(c1), lower=FALSE)) * coef(c1),
mean(g1$fitted.values*(1-g1$fitted.values))*g1$coef[1:9],
mean(predict(cre1, type="response")*(1-predict(cre1, type="response")))*cre1@beta[2:10],
mean(cre2$fitted.values*(1-cre2$fitted.values))*cre2$coefficients[2:10],
mean(s1$fitted*(1-s1$fitted))*s1$coeff[1:9]),
3)
summary(g1$coef[-c(1:9)])
# mean(predict(cre1, type="response")*(1-predict(cre1, type="response")))*cre1@beta[2:10],
round(
cbind(mean(plogis(predict(c1)) * plogis(predict(c1), lower=FALSE)) * coef(c1),
mean(g1$fitted.values*(1-g1$fitted.values))*g1$coef[1:9],
# mean(predict(cre1, type="response")*(1-predict(cre1, type="response")))*cre1@beta[2:10],
mean(cre2$fitted.values*(1-cre2$fitted.values))*cre2$coefficients[2:10],
mean(s1$fitted*(1-s1$fitted))*s1$coeff[1:9]),
3)
lrtest(g1, glm(difficnewjob_dummy ~ skillsp+income + manualwork + unemployed_reg +
age + churchatt + temporary + educyears + percentimmigr+0,
family=binomial, data=german.cml, x=T))
logLik(g1)
logLik(glm(difficnewjob_dummy ~ skillsp+income + manualwork + unemployed_reg +
+                    age + churchatt + temporary + educyears + percentimmigr+0,
+                family=binomial, data=german.cml, x=T))
logLik(glm(difficnewjob_dummy ~ skillsp+income + manualwork + unemployed_reg +
age + churchatt + temporary + educyears + percentimmigr+0,
family=binomial, data=german.cml, x=T))
lr.model <- sp.ffe(difficnewjob_dummy ~ skillsp+income + manualwork + unemployed_reg +
age + churchatt + temporary + educyears + percentimmigr+
0, data=german0, optim.control = list(trace=TRUE))
pchisq(2*(s1$logLik-lr.model$logLik), lower=F,df=length(s1$coefficients)-length(lr.model$coefficients)) #can we treat all c_i as 0?
s1$logLik
lr.model$logLik
head(coeftest(g1)[])
head(coeftest(g1)[], 25)
head(coeftest(g1)[][-c(1:9),], 25)
head(coeftest(g1)[][-c(1:9),4])
summary(coeftest(g1)[][-c(1:9),4])
summary(coeftest(g1)[][-c(1:9),1])
summary(c1)
summary(glm(difficnewjob_dummy ~ skillsp+income + manualwork + unemployed_reg +
age + churchatt + temporary + educyears + percentimmigr+0,
family=binomial, data=german.cml, x=T))
setwd("~/Documents/code")
rm(list=ls())
library(doRNG)
library(doParallel)
library(survival)
library(plm)
library(lme4)
library(pROC)
library(Matrix)
library(spam)
library(ggplot2)
library(reshape2)
library(scales)
library(matrixStats)
library(extrafont)
library(data.table)
source("sparseFirth.R")
beck.logit <- function(alpha, cml, X, y){
theta <- c(cml, alpha)
XB <- X %*% theta
return(
-sum(ifelse(y==1,
plogis(XB, log.p=T),
plogis(XB, lower.tail = F, log.p=T))))
}
set.seed(123456)
n <- 1000
t <- 30
g <- 5.2
NT <- expand.grid(n,t,g)
B <- 1000
M <- 50 #cutpoint for numeric issue (expanded for this extreme case)
N <- NT[i, 1]
T <- NT[i, 2]
gamma <- NT[i, 3]
alpha <- rnorm(N, mean=-4)
# alpha <- rnorm(N, mean=4)
i=1
N <- NT[i, 1]
T <- NT[i, 2]
gamma <- NT[i, 3]
alpha <- rnorm(N, mean=-4)
# alpha <- rnorm(N, mean=4)
indexes <- expand.grid(1:T,1:N)
c <- rep(alpha, each=T) #this is z in the paper
r <- 0
data1 <- list(y=0)
# prop.all.zero <- 0
all.zero <- T
while(abs(r)<.3 | sum(data1$y)==0 || all.zero){
X <- rnorm(N*T)+ c #(c^3-1)/15 #nonlinear cor
#plot(X~c)
e <- rlogis(N*T) + c*gamma
r <- cor(X,c)
#print(r)
y.linear <- -2*X + e
data1 <- data.table(state=factor(indexes[,2]),
year=indexes[,1],
y.linear=y.linear,
X=X)
data1$y <- ifelse(data1$y.linear>0,1,0)
data1[, sum.y:=sum(y), by=state]
data1$cgamma <- c*gamma
within.y <- mean(data1[, mean(y), by=state]$V1)
data2 <- data1[(sum.y>0 & sum.y<T)]
data1[,state2 := ifelse((sum.y==0), N+1, state)]
data1[,state2 := ifelse((sum.y==T), N+2, state2)]
data1[,state2:=factor(state2)]
data2$state <- droplevels(data2$state)
ca <- c[data1$sum.y>0 & data1$sum.y<T]
data3 <- data1[state2==N+1]
data3$state <- droplevels(data3$state)
prop.all.zero <- 1-length(unique(data2$state))/length(unique(data1$state))
if(gamma == g[1]){
all.zero <- !((prop.all.zero <1))
}else{
all.zero <- FALSE
}
print(prop.all.zero)
}
#note: state is already a factor variable (see above)
# g1 <- try(glm(y~X, family=binomial, data=data1))
data1[,Z := mean(X), by =state]
data2[,Z := mean(X), by =state]
t2 <- system.time({g2 <- try(glm(y~X+(state)-1, family=binomial, data=data2, x=T,y=T))})[3]
# t3 <- system.time({g3 <- try(sp.ffe(y~X+(state)-1, data=data1))})[3]
Z <- tapply(data1$X, data1$state, mean) %x% rep(1, T)
t5 <- system.time({g5 <- try(glmer(y~X+(1|state)+Z, data=data1, family =binomial))})[3]
t6 <- system.time({g6 <- try(glmer(y~X+(1|state)+Z, data=data2, family =binomial))})[3]
t7 <- system.time({g7 <- try(plm(y~X, indexes=c("state", "year"), model="within", data=data2))})[3]
sample(1:nrow(data2), replace=F )
data2.k <- list()
all0 <- data1[sum.y==0]
all0
all0[state2:=NULL]
all0[,state2:=NULL]
all0
idx <- sample(1:nrow(data2), replace=F )
idx
!(1:nrow(data2)  %in% idx)
nrow(data2)
nrow(data2)/5
idx <- sample(1:nrow(data2), size=nrow(data2)/5, replace=F )
!(1:nrow(data2)  %in% idx)
idx <- sample(1:nrow(data2), size=nrow(data2)/5, replace=F )
test <- data2[idx]
train <- rbind(all0, data2[!(1:nrow(data2)  %in% idx)])
t2 <- system.time({g2.k <- try(glm(y~X+(state)-1, family=binomial, data=train[sum.y>0], x=T,y=T))})[3]
Z <- tapply(data1$X, data1$state, mean) %x% rep(1, T)
t5 <- system.time({g5.k <- try(glmer(y~X+(1|state)+Z, data=train, family =binomial))})[3]
ptest2 <- predict(g2.k, newdata=test, type="response")
ptest5 <- predict(g5.k, newdata=test, type="response")
ptest2
ptest5
test
ptest.truth <- plogis(-2*test$X + cgamma )
ptest.truth <- plogis(-2*test$X + test$cgamma )
ptest.truth
ptest5
ptest2
rmse.2k <- mean((ptest.truth-ptest2)^2)
rmse.5k <- mean((ptest.truth-ptest5)^2)
rmse.5k
rmse.2k
source('~/.active-rstudio-document')
rmse.2k
rmse.5k
rmse.2k <- mean(rmse.2k)
rmse.5k <- mean(rmse.5k)
rmse2 <- (rmse.2k < rmse.5k)
rmse2
source('~/Documents/code/logit_horserace_highCensored.R')
stopCluster(cl)
roc(test$y, ptest2)$auc[1]
indexes <- expand.grid(1:T,1:N)
c <- rep(alpha, each=T) #this is z in the paper
r <- 0
data1 <- list(y=0)
# prop.all.zero <- 0
all.zero <- T
while(abs(r)<.3 | sum(data1$y)==0 || all.zero){
X <- rnorm(N*T)+ c #(c^3-1)/15 #nonlinear cor
#plot(X~c)
e <- rlogis(N*T) + c*gamma
r <- cor(X,c)
#print(r)
y.linear <- -2*X + e
data1 <- data.table(state=factor(indexes[,2]),
year=indexes[,1],
y.linear=y.linear,
X=X)
data1$y <- ifelse(data1$y.linear>0,1,0)
data1[, sum.y:=sum(y), by=state]
data1$cgamma <- c*gamma
within.y <- mean(data1[, mean(y), by=state]$V1)
data2 <- data1[(sum.y>0 & sum.y<T)]
data1[,state2 := ifelse((sum.y==0), N+1, state)]
data1[,state2 := ifelse((sum.y==T), N+2, state2)]
data1[,state2:=factor(state2)]
data2$state <- droplevels(data2$state)
ca <- c[data1$sum.y>0 & data1$sum.y<T]
data3 <- data1[state2==N+1]
data3$state <- droplevels(data3$state)
prop.all.zero <- 1-length(unique(data2$state))/length(unique(data1$state))
if(gamma == g[1]){
all.zero <- !((prop.all.zero <1))
}else{
all.zero <- FALSE
}
print(prop.all.zero)
}
#note: state is already a factor variable (see above)
# g1 <- try(glm(y~X, family=binomial, data=data1))
data1[,Z := mean(X), by =state]
data2[,Z := mean(X), by =state]
t2 <- system.time({g2 <- try(glm(y~X+(state)-1, family=binomial, data=data2, x=T,y=T))})[3]
# t3 <- system.time({g3 <- try(sp.ffe(y~X+(state)-1, data=data1))})[3]
Z <- tapply(data1$X, data1$state, mean) %x% rep(1, T)
t5 <- system.time({g5 <- try(glmer(y~X+(1|state)+Z, data=data1, family =binomial))})[3]
t6 <- system.time({g6 <- try(glmer(y~X+(1|state)+Z, data=data2, family =binomial))})[3]
t7 <- system.time({g7 <- try(plm(y~X, indexes=c("state", "year"), model="within", data=data2))})[3]
if(class(g2)=="try-error"||!g2$conv||any(is.na(g2$coef))|| abs(g2$coef[1]) > M){
g2 <- list(coef=rep(NA,N+1))
mar2 <- NA; bmar2 <- NA; ame2 <- NA; t2 <- NA
}else{
prob.g2 <- g2$fitted
prob.g2.new <- g2$fitted #if MEM use predict(g2, newdata=newData2)
mar2 <- mean((prob.g2 -plogis(-2*data2$X + data2$cgamma))^2)
bmar2 <-(mean(prob.g2 -plogis(-2*data2$X + data2$cgamma)))
ame2 <-(prob.g2.new*(1-prob.g2.new)*(coef(g2)[1]))
}
# if(class(g3)=="try-error"||!(g3$conv==0) || any(is.na(g3$coefficients))||any(abs(g3$coefficients) > M)){
#   g3 <- list(coef=rep(NA,N+1))
#   mar3 <- NA; bmar3 <- NA; ame3 <- NA; t3 <- NA
#   mar3.cml <- NA; bmar3.cml <- NA; ame3.cml <- NA;
# }else{
#   g3$coef.table <- NULL
#   X2 <- sparse.model.matrix(y~X+(state)-1, data=data2)
#   X3 <- sparse.model.matrix(y~X+(state)-1, data=data3)
#
#   prob2 <- plogis(drop(X2 %*%g3$coef[c(1, unique(as.numeric(as.character(data2$state)))+1)]))
#   prob3 <- plogis(drop(X3 %*%g3$coef[c(1, unique(as.numeric(as.character(data3$state)))+1)])) #if mem use X.mem2
#
#
#
#   mar3.cml <- mean((prob2 -plogis(-2*data2$X + data2$cgamma))^2)
#   bmar3.cml <-(mean(prob2 -plogis(-2*data2$X + data2$cgamma)))
#   ame3.cml <- (prob2*(1-prob2)*(coef(g3)[1]))
#
#   mar3 <- mean((prob3 -plogis(-2*data3$X + data3$cgamma))^2)
#   bmar3 <-(mean(prob3 -plogis(-2*data3$X + data3$cgamma)))
#   ame3 <- (prob3*(1-prob3)*(coef(g3)[1]))
# }
#
data2[,Z := mean(X), by =state]
data3[,Z := mean(X), by =state]
if(class(g5)=="try-error"||g5@optinfo$conv$opt!=0||anyNA(coef(g5)$state)||abs(unique(coef(g5)$state$X)) > M){
beta.CRE <- NA;alpha.CRE <- rep(NA,N);mar5 <- NA;bmar5 <- NA; ame5 <- NA; t5 <- NA
alpha.CRE.cml <- NA;mar5.cml <- NA;bmar5.cml <- NA; ame5.cml <- NA; ALPHA.cre <- NA
}else{
beta.CRE <- g5@beta[2]
alpha.CRE <- rowSums(unique(cbind(1, data1$Z)) * as.matrix(coef(g5)$state[,-2]))
alpha.CRE.cml <- alpha.CRE[unique(as.numeric(as.character(data2$state)))]
ALPHA.cre <- alpha.CRE[unique(as.numeric(as.character(data3$state)))]
if(any(abs(c(beta.CRE, alpha.CRE))> M)){
beta.CRE <- NA;alpha.CRE <- rep(NA,N);mar5 <- NA;bmar5 <- NA; ame5 <- NA; t5 <- NA
alpha.CRE.cml <- NA;mar5.cml <- NA;bmar5.cml <- NA; ame5.cml <- NA;ALPHA.cre <- NA
}else{
mar5.cml <- mean((predict(g5, type="response", newdata=data2) -plogis(-2*data2$X + data2$cgamma))^2)
bmar5.cml <-(mean(predict(g5, type="response", newdata=data2) -plogis(-2*data2$X + data2$cgamma)))
ame5.cml <- ((predict(g5, type="response", newdata=data2)*(1-predict(g5, type="response", newdata=data2))*(coef(g5)$state$X[1])))
mar5 <- mean((predict(g5, type="response", newdata=data3) -plogis(-2*data3$X + data3$cgamma))^2)
bmar5 <-(mean(predict(g5, type="response", newdata=data3) -plogis(-2*data3$X + data3$cgamma)))
ame5 <- ((predict(g5, type="response", newdata=data3)*(1-predict(g5, type="response", newdata=data3))*(coef(g5)$state$X[1])))
}
}
if(class(g6)=="try-error"||g6@optinfo$conv$opt!=0||anyNA(coef(g6)$state)||abs(unique(coef(g6)$state$X)) > M){
beta.CRE6 <- NA;mar6 <- NA;bmar6 <- NA; ame6 <- NA; t6 <- NA;
alpha.CRE.cml6 <- NA;mar6.cml <- NA;bmar6.cml <- NA; ame6.cml <- NA;
}else{
beta.CRE6 <- g6@beta[2]
# alpha.CRE6 <- rowSums(unique(data2$Z) * as.matrix(coef(g6)$state[,-2]))
alpha.CRE.cml6 <- rowSums(cbind(1,unique(data2$Z)) * as.matrix(coef(g6)$state[,-2]))
if(any(abs(c(beta.CRE6, alpha.CRE.cml6))> M)){
beta.CRE6 <- NA;mar6 <- NA;bmar6 <- NA; ame6 <- NA; t6 <- NA;
alpha.CRE.cml6 <- NA;mar6.cml <- NA;bmar6.cml <- NA; ame6.cml <- NA;
}else{
mar6.cml <- mean((predict(g6, type="response", newdata=data2) -plogis(-2*data2$X + data2$cgamma))^2)
bmar6.cml <-(mean(predict(g6, type="response", newdata=data2) -plogis(-2*data2$X + data2$cgamma)))
ame6.cml <- ((predict(g6, type="response", newdata=data2)*(1-predict(g6, type="response", newdata=data2))*(coef(g6)$state$X[1])))
}
}
if(class(g7)=="try-error" || any(is.na(g7$coef))||any(abs(g7$coef) > M)){
mar7 <- NA; bmar7 <- NA; ame7 <- NA; t7 <- NA
mar7.cml <- NA; bmar7.cml <- NA; ame7.cml <- NA;
}else{
g7.fitted <- data2$X * coef(g7)+fixef(g7)%x%rep(1,T)
mar7.cml <- mean((g7.fitted - plogis(-2*data2$X + data2$cgamma))^2)
bmar7.cml  <-(mean(g7.fitted - plogis(-2*data2$X + data2$cgamma)))
# mar7 <- mean((g7.fitted[data1$sum.y==0] - plogis(-2*data3$X + data3$cgamma))^2)
# bmar7 <-(mean(g7.fitted[data1$sum.y==0] - plogis(-2*data3$X + data3$cgamma)))
ame7.cml <- coef(g7)
}
# m3.cml <- mean((g3$coef[-1][unique(as.numeric(as.character(data2$state)))]- unique(data2$cgamma))^2)
m2 <- mean((g2$coef[-1]-unique(data2$cgamma))^2)
m5.cml <- mean((alpha.CRE.cml-unique(data2$cgamma))^2)
m6.cml <- mean((alpha.CRE.cml6-unique(data2$cgamma))^2)
# m3 <- mean((g3$coef[-1][unique(as.numeric(as.character(data3$state)))]-unique(data3$cgamma))^2)
m5 <- mean((ALPHA.cre-unique(data3$cgamma))^2)
# b3.cml <- mean((g3$coef[-1][unique(as.numeric(as.character(data2$state)))]-unique(data2$cgamma)))
b2 <- mean((g2$coef[-1]-unique(data2$cgamma)))
b5.cml <- mean((alpha.CRE.cml-unique(data2$cgamma)))
b6.cml <- mean((alpha.CRE.cml6-unique(data2$cgamma)))
# b3 <- mean((g3$coef[-1][unique(as.numeric(as.character(data3$state)))]-unique(data3$cgamma)))
b5 <- mean((ALPHA.cre-unique(data3$cgamma)))
ame.truth.cml <- mean((plogis(-2*data2$X + data2$cgamma)*(1-plogis(-2*data2$X + data2$cgamma))*-2))
ame.truth <- mean((plogis(-2*data3$X + data3$cgamma)*(1-plogis(-2*data3$X + data3$cgamma))*-2))
# ame3.cml <- mean(ame3.cml)
ame5.cml <- mean(ame5.cml)
ame6.cml <- mean(ame6.cml)
ame2 <- mean(ame2)
# ame3 <- mean(ame3)
ame5 <- mean(ame5)
#naive form of CV
auc.2k <- auc.5k <- rep(0, 5)
all0 <- data1[sum.y==0]
all0[,state2:=NULL]
for(k in 1:5){
idx <- sample(1:nrow(data2), size=nrow(data2)/5, replace=F )
test <- data2[idx]
train <- rbind(all0, data2[!(1:nrow(data2)  %in% idx)])
t2 <- system.time({g2.k <- try(glm(y~X+(state)-1, family=binomial, data=train[sum.y>0], x=T,y=T))})[3]
Z <- tapply(data1$X, data1$state, mean) %x% rep(1, T)
t5 <- system.time({g5.k <- try(glmer(y~X+(1|state)+Z, data=train, family =binomial))})[3]
ptest2 <- predict(g2.k, newdata=test, type="response")
ptest5 <- predict(g5.k, newdata=test, type="response")
auc.2k[k] <- roc(test$y, ptest2)$auc[1]
auc.5k[k] <- roc(test$y, ptest5)$auc[1]
}
auc.2k
auc.5k
auc.2k <- mean(auc.2k)
auc.5k <- mean(auc.5k)
auc.CV <- (auc.2k > auc.5k)
auc.CV
source('~/Documents/code/logit_horserace_highCensored.R')
source('~/Documents/code/logit_horserace_highCensored.R')
stopCluster(cl)
source('~/Documents/code/logit_horserace_highCensored.R')
stopCluster(cl)
source('~/Documents/code/logit_horserace_highCensored.R')
warnings()
source('~/Documents/code/logit_horserace_highCensored.R')
Sys.time(0)
Sys.time()
Sys.time()
dim(out)
rm(list=ls())
library(ggplot2)
library(MASS)
library(lme4)
library(survival)
library(stargazer)
load("dirtypoolout.rdata")
setwd("~/Dropbox/xtlogit/JOP_Revisions_code")
rm(list=ls())
library(ggplot2)
library(MASS)
library(lme4)
library(survival)
library(stargazer)
load("dirtypoolout.rdata")
cre.cml.margins
cre.cml.margins$AME
cre.cml.margins$AME/mldv.margins$AME
mldv.margins$AME/cre.cml.margins$AME
median(mldv.margins$AME/cre.cml.margins$AME)
median(mldv.margins$AME/rcre.margins$AME)
mean(mldv.margins$AME/cre.cml.margins$AME)
mean((mldv.margins$AME/cre.cml.margins$AME)[-4])
mldv.margins$AME
mean((mldv.margins$AME/rcre.margins$AME)[-4])
